# Esperas desnecessÃ¡rias

Essa Ã© uma das piores mÃ¡s prÃ¡ticas, e ainda assim, um tema recorrente quando se fala em testes automatizados de interface grÃ¡fica de usuÃ¡rio.

A mensagem Ã© a seguinte. NÃ£o use `cy.wait(3000)`, `cy.wait(10000)`, ou seja lÃ¡ qual for o valor em milissegundos. Isso torna os testes mais lentos do que o necessÃ¡rio, alÃ©m de as vezes poder tornÃ¡-los _flaky_.

O Cypress jÃ¡ possui esperas e _retries_ automÃ¡ticos por padrÃ£o, e se tal padrÃ£o nÃ£o for o suficiente para seu caso, vocÃª pode sobrescrever tais valores (_timeouts_) via configuraÃ§Ã£o, ou atÃ© mesmo para um comando especÃ­fico.

Por exemplo, digamos que seus testes executem em um ambiente com poucos recursos computacionais, e portanto, a aplicaÃ§Ã£o demora para carregar. Neste caso, digamos que vocÃª queira fazer login e o teste falha no preenchimento do formulÃ¡rio devido aos elementos de tal formulÃ¡rio ainda nÃ£o terem renderizado na pÃ¡gina. Imaginemos um teste como o seguinte:

```js
// cypress/integration/login.spec.sj

describe('Login', () => {
  it('successfully', () => {
    cy.visit('https://example.com/login')

    cy.get('[data-cy="email-field"]')
      .type(Cypress.env('user_email'))
    cy.get('[data-cy="password-field"]')
      .type(Cypress.env('user_password'))
    cy.get('button[type="submit"]')
      .click()

    cy.get('[data-cy="avatar"]')
      .should('be.visible')
  })
})
```

Uma alternativa simples Ã© sobrescrever o _timeout_ padrÃ£o para o comando em que o teste estÃ¡ falhando.

Digamos que o teste sempre falhe na hora de preencher o email do usuÃ¡rio, visto que tal campo demora para renderizar.

Uma alternativa para resolver tal problema seria a seguinte:

```js
// cypress/integration/login.spec.sj

describe('Login', () => {
  it('successfully', () => {
    cy.visit('https://example.com/login')

    cy.get('[data-cy="email-field"]')
      .type(Cypress.env('user_email'), { timeout: 10000 })
    cy.get('[data-cy="password-field"]')
      .type(Cypress.env('user_password'))
    cy.get('button[type="submit"]')
      .click()

    cy.get('[data-cy="avatar"]')
      .should('be.visible')
  })
})
```

Ou seja, agora, em vez do Cypress esperar por no mÃ¡ximo `4000` milissegundos antes de falhar (valor padrÃ£o), irÃ¡ esperar um mÃ¡ximo de `10000` milissegundos, porÃ©m, se apÃ³s, digamos, `6000` milissegundos o campo aparecer, o teste irÃ¡ seguir adiante.

## ConteÃºdos sugeridos

Antes de seguir adiante, tenho algumas recomendaÃ§Ãµes de conteÃºdos sobre o assunto pra te indicar:

- [Por que nÃ£o se deve utilizar sleeps em testes automatizados](https://talkingabouttesting.com/2017/11/20/por-que-nao-se-deve-utilizar-sleeps-em-testes-automatizados/)
- [Unnecessary Waiting - Cypress docs](https://docs.cypress.io/guides/references/best-practices#Unnecessary-Waiting) (em inglÃªs)

## ExercÃ­cio

Abra o arquivo [`cypress/integration/unnecessary-waiting/sample.spec.js`](../cypress/integration/unnecessary-waiting/sample.spec.js) e simplesmente remova o `cy.wait(3000)` adiconado desnecessÃ¡riamente no teste. Deixe o Cypress lidar com a espera por conta prÃ³pria! ğŸ™Œ

> E se por algum motivo vocÃª precisar, aumente o _timeout_ padrÃ£o conforme explicado acima.

___

Estamos quase lÃ¡. ğŸ

VÃ¡ para a [aula 10](./10.md) para conhecer a dÃ©cima mÃ¡ prÃ¡tica (abstraÃ§Ãµes erradas), e como lidar com ela.
